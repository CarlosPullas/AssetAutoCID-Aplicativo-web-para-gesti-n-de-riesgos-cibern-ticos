\begin{lstlisting}[language=Python, caption={modules/db.py - Modelos SQLite (SQLAlchemy) + cálculo de riesgo}]
# modules/db.py
# ------------------------------------------------------------
# Define la capa de persistencia (SQLite) usando SQLAlchemy.
# Modelos:
#   - Asset: activos de información (descubiertos o manuales)
#   - Risk: riesgos asociados a un activo (amenaza + vulnerabilidad + control)
#   - Treatment: tratamiento del riesgo (estrategia + control ISO 27002 + responsable)
#   - Residual: evaluación posterior (riesgo residual)
#
# Además incluye risk_score() para calcular el nivel de riesgo:
#   riesgo = probabilidad * impacto
# ------------------------------------------------------------

from datetime import datetime
from flask_sqlalchemy import SQLAlchemy

# Instancia global de SQLAlchemy. Se inicializa en app/server.py con db.init_app(app)
db = SQLAlchemy()


# ============================================================
# FUNCIÓN DE CÁLCULO DE RIESGO (criterio del grupo)
# ============================================================

def risk_score(probabilidad: int, impacto: int) -> int:
    """
    Calcula el riesgo como:
        Riesgo = Probabilidad x Impacto

    Escala recomendada (ejemplo):
      probabilidad: 1 a 5
      impacto:      1 a 5
      score:        1 a 25

    Puedes ajustar rangos en formularios HTML.
    """
    # Validación básica (evita errores si envían cosas raras)
    p = max(1, min(int(probabilidad), 5))
    i = max(1, min(int(impacto), 5))
    return p * i


# ============================================================
# MODELO: ASSET (Activos)
# ============================================================

class Asset(db.Model):
    """
    Tabla Asset:
    Representa un activo de información (hardware, servicio, BD, etc.)
    Puede provenir de:
      - Descubrimiento automático por Nmap (IP + servicios)
      - Registro manual (cloud, RRSS, correo, etc.)
    """

    __tablename__ = "assets"

    id = db.Column(db.Integer, primary_key=True)

    # Identificación técnica
    ip = db.Column(db.String(64), nullable=True, index=True)
    hostname = db.Column(db.String(128), nullable=True)

    # Contexto organizacional
    ubicacion = db.Column(db.String(128), nullable=True)
    tipo = db.Column(db.String(64), nullable=False)          # Hardware / Servicio / Base de datos
    descripcion = db.Column(db.Text, nullable=False)

    # Clasificación
    sensibilidad = db.Column(db.String(32), nullable=False, default="Interna")  # Pública/Interna/Confidencial
    criticidad = db.Column(db.Integer, nullable=False, default=9)              # suma CID

    created_at = db.Column(db.DateTime, default=datetime.now)

    # Relación: un activo tiene muchos riesgos
    risks = db.relationship("Risk", backref="asset", lazy=True, cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Asset id={self.id} ip={self.ip} tipo={self.tipo}>"


# ============================================================
# MODELO: RISK (Riesgos)
# ============================================================

class Risk(db.Model):
    """
    Tabla Risk:
    Representa un riesgo asociado a un activo.
    Campos mínimos de la consigna:
      - amenaza
      - vulnerabilidad
      - controles existentes
      - análisis: probabilidad, impacto
      - valoración: riesgo inherente (p x i)
      - estado: Abierto / En tratamiento / Verificado / Cerrado
      - observaciones: comunicación y consulta
    """

    __tablename__ = "risks"

    id = db.Column(db.Integer, primary_key=True)

    # FK al activo
    asset_id = db.Column(db.Integer, db.ForeignKey("assets.id"), nullable=False)

    # Identificación del riesgo
    amenaza = db.Column(db.String(256), nullable=False)
    vulnerabilidad = db.Column(db.String(256), nullable=False)
    control_existente = db.Column(db.String(256), nullable=False, default="N/A")

    # Análisis
    probabilidad = db.Column(db.Integer, nullable=False, default=3)
    impacto = db.Column(db.Integer, nullable=False, default=3)

    # Valoración del riesgo inherente (antes de controles nuevos)
    riesgo_inherente = db.Column(db.Integer, nullable=False, default=9)

    # Comunicación y consulta
    observaciones = db.Column(db.Text, nullable=True)

    # Ciclo de vida del riesgo
    estado = db.Column(db.String(32), nullable=False, default="Abierto")

    created_at = db.Column(db.DateTime, default=datetime.now)

    # Relación: un riesgo tiene muchos tratamientos
    treatments = db.relationship("Treatment", backref="risk", lazy=True, cascade="all, delete-orphan")

    # Relación: un riesgo tiene un residual (última evaluación)
    residual = db.relationship("Residual", backref="risk", uselist=False, cascade="all, delete-orphan")

    def __repr__(self) -> str:
        return f"<Risk id={self.id} asset_id={self.asset_id} score={self.riesgo_inherente} estado={self.estado}>"


# ============================================================
# MODELO: TREATMENT (Tratamiento del riesgo)
# ============================================================

class Treatment(db.Model):
    """
    Tabla Treatment:
    Registra el tratamiento seleccionado por el analista.
    Consigna:
      - estrategia: mitigar / transferir / aceptar / evitar
      - referencia a ISO/IEC 27002:2022 (control_iso)
      - control propuesto (acción concreta)
      - responsable
      - fecha objetivo
      - estado del control
    """

    __tablename__ = "treatments"

    id = db.Column(db.Integer, primary_key=True)

    # FK al riesgo
    risk_id = db.Column(db.Integer, db.ForeignKey("risks.id"), nullable=False)

    estrategia = db.Column(db.String(32), nullable=False)   # Mitigar/Transferir/Aceptar/Evitar
    control_iso = db.Column(db.String(128), nullable=True)  # Ej: 8.9 Configuration management (o lo que ustedes escriban)
    control_propuesto = db.Column(db.Text, nullable=False)  # Acción propuesta
    responsable = db.Column(db.String(128), nullable=False)

    fecha_objetivo = db.Column(db.String(32), nullable=True)    # string para simplicidad (YYYY-MM-DD)
    estado_control = db.Column(db.String(32), nullable=False, default="Pendiente")  # Pendiente/En progreso/Implementado

    created_at = db.Column(db.DateTime, default=datetime.now)

    def __repr__(self) -> str:
        return f"<Treatment id={self.id} risk_id={self.risk_id} estrategia={self.estrategia}>"


# ============================================================
# MODELO: RESIDUAL (Riesgo residual)
# ============================================================

class Residual(db.Model):
    """
    Tabla Residual:
    Evaluación posterior a implementar controles.
    Consigna:
      - probabilidad residual
      - impacto residual
      - riesgo residual
      - fecha de evaluación
    """

    __tablename__ = "residuals"

    id = db.Column(db.Integer, primary_key=True)

    # FK al riesgo
    risk_id = db.Column(db.Integer, db.ForeignKey("risks.id"), nullable=False, unique=True)

    prob_residual = db.Column(db.Integer, nullable=False, default=2)
    imp_residual = db.Column(db.Integer, nullable=False, default=2)

    riesgo_residual = db.Column(db.Integer, nullable=False, default=4)
    fecha_evaluacion = db.Column(db.String(32), nullable=True)

    created_at = db.Column(db.DateTime, default=datetime.now)

    def __repr__(self) -> str:
        return f"<Residual id={self.id} risk_id={self.risk_id} score={self.riesgo_residual}>"

\end{lstlisting}
